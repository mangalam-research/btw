"""
Even though signals are generated by the models, they are a
concern that crosses across the kind of testing we do on models, so we
have a separate module for testing them.

"""

import os

from django.test import TestCase
from django.contrib.auth import get_user_model

from .. import signals
from ..models import Entry, ChangeRecord, Chunk
from .. import xml
from .util import launch_fetch_task, get_valid_document_data
from lib.util import DisableMigrationsMixin

launch_fetch_task()

dirname = os.path.dirname(__file__)
user_model = get_user_model()

class SignalGrabber(object):

    def __init__(self, signals):
        self.received = None
        self.signals = signals

    def __enter__(self):
        self.received = {signal: [] for signal in self.signals}
        for signal in self.signals:
            signal.connect(self.handler)
        return self

    def handler(self, sender, **kwargs):
        # Yes, we remove the "signal" key from kwargs.
        signal = kwargs.pop("signal")
        self.received[signal].append(kwargs)

    def __exit__(self, exc_type, exc_value, traceback):
        for signal in self.signals:
            signal.disconnect(self.handler)

valid_editable = get_valid_document_data()
xmltree = xml.XMLTree(valid_editable)
schema_version = xmltree.extract_version()

class SignalTestCase(DisableMigrationsMixin, TestCase):
    fixtures = list(os.path.join(dirname, "fixtures", x)
                    for x in ("users.json", "one_entry.json"))

    def setUp(self):
        self.foo = user_model.objects.get(username="foo")
        self.entry = Entry.objects.get(id=1)
        self.signals = (signals.entry_available,
                        signals.entry_unavailable,
                        signals.entry_newly_published,
                        signals.entry_unpublished)
        c = Chunk(data=valid_editable,
                  schema_version=schema_version,
                  # Yes, we cheat by setting _value to True right here
                  # and now. Otherwise, each test would require
                  # checking the the valid data is valid!
                  # ``get_valid_document_data`` checks the data
                  # already.
                  _valid=True)
        c.save()
        self.valid = Entry()
        self.valid.update(self.foo,
                          "q",
                          c,
                          "foo2",
                          ChangeRecord.CREATE,
                          ChangeRecord.MANUAL)

    def assertSignals(self, grabber, expected):
        ex = {signal: [] for signal in self.signals}
        ex.update(expected)
        self.assertEqual(grabber.received, ex)

    def test_entry_creation_sends_entry_available(self):
        with SignalGrabber(self.signals) as grabber:
            entry = Entry()
            entry.update(
                self.foo,
                "q",
                self.entry.latest.c_hash,
                self.entry.lemma + " copy",
                ChangeRecord.CREATE,
                ChangeRecord.MANUAL)
            self.assertSignals(grabber, {
                signals.entry_available: [{'instance': entry}]
            })

    def test_entry_deletion_sends_entry_unavailable(self):
        entry = Entry()
        entry.update(
            self.foo,
            "q",
            self.entry.latest.c_hash,
            self.entry.lemma + " copy",
            ChangeRecord.CREATE,
            ChangeRecord.MANUAL)

        with SignalGrabber(self.signals) as grabber:
            entry.mark_deleted(self.foo)
            self.assertSignals(grabber, {
                signals.entry_unavailable: [{'instance': entry}]
            })

    def test_entry_undeletion_sends_entry_available(self):
        entry = Entry()
        entry.update(
            self.foo,
            "q",
            self.entry.latest.c_hash,
            self.entry.lemma + " copy",
            ChangeRecord.CREATE,
            ChangeRecord.MANUAL)

        entry.mark_deleted(self.foo)
        with SignalGrabber(self.signals) as grabber:
            entry.undelete(self.foo)
            self.assertSignals(grabber, {
                signals.entry_available: [{'instance': entry}]
            })

    def test_entry_publishing_sends_entry_newly_published(self):
        entry = self.valid
        with SignalGrabber(self.signals) as grabber:
            self.assertTrue(entry.latest.publish(self.foo))
            self.assertSignals(grabber, {
                signals.entry_newly_published: [{'instance': entry}]
            })

    def test_republishing_does_not_send_entry_newly_published(self):
        entry = self.valid
        self.assertTrue(entry.latest.publish(self.foo))
        with SignalGrabber(self.signals) as grabber:
            entry.update(
                self.foo,
                "q",
                entry.latest.c_hash,
                entry.lemma,
                ChangeRecord.UPDATE,
                ChangeRecord.MANUAL)
            self.assertTrue(entry.latest.publish(self.foo))
            self.assertSignals(grabber, {})

    def test_unpublishing_does_not_send_entry_newly_published(self):
        entry = self.valid
        self.assertTrue(entry.latest.publish(self.foo))
        entry.update(
            self.foo,
            "q",
            entry.latest.c_hash,
            entry.lemma,
            ChangeRecord.UPDATE,
            ChangeRecord.MANUAL)
        self.assertTrue(entry.latest.publish(self.foo))
        with SignalGrabber(self.signals) as grabber:
            entry.latest_published.unpublish(self.foo)
            self.assertSignals(grabber, {})

    def test_completely_unpublishing_sends_entry_newly_published(self):
        entry = self.valid
        self.assertTrue(entry.latest.publish(self.foo))
        entry.update(
            self.foo,
            "q",
            entry.latest.c_hash,
            entry.lemma,
            ChangeRecord.UPDATE,
            ChangeRecord.MANUAL)
        self.assertTrue(entry.latest.publish(self.foo))
        entry.latest_published.unpublish(self.foo)
        with SignalGrabber(self.signals) as grabber:
            entry.latest_published.unpublish(self.foo)
            self.assertSignals(grabber, {
                signals.entry_unpublished: [{'instance': entry}]
            })
