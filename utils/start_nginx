#!/usr/bin/env python

import sys
import tempfile
import os
import subprocess
import atexit
import shutil
import signal
import argparse
from selenic import outil

os.environ['BTW_ENV'] = 'selenium'
os.environ['DJANGO_SETTINGS_MODULE'] = 'btw.test_settings'
# Necessary to find the settings...
sys.path.append(".")

parser = argparse.ArgumentParser()
parser.add_argument('--dump-database-names', action='store_true',
                    help='dump the database names and associated user '
                    'names and exit')
parser.add_argument("fifo_to_server")
parser.add_argument("fifo_from_server")
parser.add_argument("nginx_port")
options = parser.parse_args()

from django.conf import settings
name_users = [(db.get('TEST_NAME') or db.get('NAME'), db['USER'])
              for db in settings.DATABASES.itervalues()]

if options.dump_database_names:
    for name, user in name_users:
        print name, db['USER']
    exit(0)

fifo_to_server = options.fifo_to_server
fifo_from_server = options.fifo_from_server
nginx_port = options.nginx_port

server = None
tmpdir = None
tmpconf = None
clean_databases = False

def cleanup(*_whatever):
    # Make sure that cleanup happens!
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    signal.signal(signal.SIGTERM, signal.SIG_IGN)

    global server
    global tmpdir
    global tmpconf
    global clean_databases

    if server:
        if server.poll() is None:
            server.terminate()
        server = None

    # We must kill the workers first. Otherwise, it can lead to a
    # cascading error which will cause Redis to fill up. (Basically, a
    # task could be restarted over and over again, causing events to
    # be stored in Redis until memory is exhausted.)
    try:
        subprocess.check_call(['./manage.py', 'btwworker', 'stop', '--all'])
    except:
        sys.stderr.write("Cannot stop workers.\n")

    try:
        subprocess.check_call(['./manage.py', 'btwredis', 'stop'])
    except:
        sys.stderr.write("Cannot stop redis.\n")

    if clean_databases:
        for name, _ in name_users:
            subprocess.check_call(['dropdb', name])
        clean_databases = False

    if tmpconf:
        subprocess.call(["nginx", "-c", tmpconf, "-s", "stop"])
        tmpconf = None

    if tmpdir:
        shutil.rmtree(tmpdir)
        tmpdir = None

atexit.register(cleanup)
signal.signal(signal.SIGINT, cleanup)
signal.signal(signal.SIGTERM, cleanup)

tmpdir = tempfile.mkdtemp(prefix='btw-nginx-tmp')
tmpconf = os.path.join(tmpdir, "nginx.conf")

for d in ["var/run", "var/log", "var/lib/nginx", "var/log/btw"]:
    os.makedirs(os.path.join(tmpdir, d))

local_conf_path = os.path.join("local_config", "nginx.conf")
conf_path = os.path.join("config", "nginx.conf")

read_from = local_conf_path if os.path.exists(local_conf_path) \
    else conf_path

server_port = str(outil.get_unused_port())
with open(read_from) as cfg, open(tmpconf, 'w') as tmpcfg:
    tmpcfg.write(cfg.read().replace('@PWD@', os.getcwd())
                 .replace('@TMPDIR@', tmpdir)
                 .replace('@PORT@', nginx_port)
                 .replace('@SERVER_PORT@', server_port))

for name, user in name_users:
    subprocess.check_call(['createdb', name])
    clean_databases = True
    subprocess.check_call(
        ['psql', '-c', 'GRANT ALL ON ALL TABLES IN SCHEMA public TO ' + user,
         name])
    subprocess.check_call(['./manage.py', 'syncdb', '--noinput'])
    subprocess.check_call(['./manage.py', 'migrate'])
    subprocess.check_call(['./manage.py', 'btwdb', 'set_site_name'])
    subprocess.check_call(['./manage.py', 'btwredis', 'start'])
    subprocess.check_call(['./manage.py', 'clearcache', '--all'])
    subprocess.check_call(['./manage.py', 'btwworker', 'start', '--all'])
    # Give time to the workers to start.
    import time
    time.sleep(2)
    subprocess.check_call(['./manage.py', 'btwcheck'])

pid_to_name = {}
server = subprocess.Popen(["./manage.py", "liveserver",
                           "localhost:" + server_port, fifo_to_server,
                           fifo_from_server])
pid_to_name[server.pid] = "liveserver"

# nginx spawns a master and immediately returns
subprocess.check_call(["nginx", "-c", tmpconf])

while True:
    try:
        pid, status = os.wait()
    except OSError:  # Will be raised when there are no children.
        break

    if status:
        raise Exception(pid_to_name[pid] + " failed with status " +
                        str(status))

print "Terminating..."
